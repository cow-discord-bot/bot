use std::collections::BTreeSet;
use std::path::{Path, PathBuf};

// #weloveduplicatingcode
pub trait ExpectError<T> {
	fn expect_error(
		self,
		msg: &str,
	) -> T;
}

impl<T, E: std::fmt::Debug> ExpectError<T> for Result<T, E> {
	fn expect_error(
		self,
		msg: &str,
	) -> T {
		self.expect(&format!("\x1b[31;1m[ERROR] {}\x1b[0m", msg))
	}
}

fn process_dir(
	dir_path: &Path,
	base_path: &Path,
	module_entries: &mut BTreeSet<String>,
	dir_modules: &mut BTreeSet<String>,
	function_entries: &mut Vec<String>,
	mod_dirs: &mut Vec<PathBuf>,
) {
	mod_dirs.push(dir_path.to_path_buf());

	for entry in std::fs::read_dir(dir_path)
		.expect_error(&format!("Failed to read {:?} directory", dir_path))
	{
		if let Ok(entry) = entry {
			let path = entry.path();

			if path.is_dir() {
				if let Some(dir_name) = path.file_name().and_then(|s| s.to_str()) {
					dir_modules.insert(format!("pub mod {};", dir_name));

					process_dir(
						&path,
						base_path,
						module_entries,
						dir_modules,
						function_entries,
						mod_dirs,
					);
				}
			} else if path.is_file() {
				if path.extension().map_or(false, |ext| ext == "rs") {
					if let Some(filename) = path.file_stem().and_then(|s| s.to_str()) {
						if filename == "mod" {
							continue;
						}

						let relative_path = path.strip_prefix(base_path).unwrap_or(&path);
						let parent_parts: Vec<_> = relative_path
							.parent()
							.unwrap()
							.components()
							.map(|c| c.as_os_str().to_string_lossy())
							.collect();

						if filename.ends_with("_command") {
							module_entries.insert(format!("pub mod {};", filename));

							let command_name = filename.strip_suffix("_command").unwrap();
							let function_path = format!(
								"{}::{}::{}",
								parent_parts.join("::"),
								filename,
								command_name
							);
							function_entries.push(format!("{}()", function_path));
						} else {
							module_entries.insert(format!("pub mod {};", filename));
						}
					}
				}
			}
		}
	}
}

fn main() {
	let base_path = PathBuf::from("src/commands");
	let mut module_entries: BTreeSet<String> = BTreeSet::new();
	let mut dir_modules: BTreeSet<String> = BTreeSet::new();
	let mut function_entries = vec![];
	let mut mod_dirs = Vec::new();

	process_dir(
		&base_path,
		&base_path,
		&mut module_entries,
		&mut dir_modules,
		&mut function_entries,
		&mut mod_dirs,
	);

	mod_dirs.sort();
	mod_dirs.dedup();

	for dir in &mod_dirs {
		let modules: Vec<_> = std::fs::read_dir(dir)
			.expect_error(&format!("Failed to read {:?} directory", dir))
			.filter_map(|entry| {
				let entry = entry.ok()?;
				let path = entry.path();
				if path.is_file()
					&& path.extension().map_or(false, |ext| ext == "rs")
					&& path.file_stem().map_or(true, |s| s != "mod")
				{
					path.file_stem()
						.and_then(|s| s.to_str())
						.map(|s| format!("pub mod {};", s))
				} else if path.is_dir() {
					path.file_name()
						.and_then(|s| s.to_str())
						.map(|s| format!("pub mod {};", s))
				} else {
					None
				}
			})
			.collect();

		let mut mod_content = format!(
			"//! This file is autogenerated by build.rs, do not edit.\n#![cfg_attr(rustfmt, rustfmt_skip)]\n\n{}",
			modules.join("\n")
		);

		if *dir == base_path {
			mod_content.push_str(&format!(
                "\n\npub fn get_all_commands() -> Vec<poise::Command<crate::Data, crate::Error>> {{\n\tvec![{}]\n}}",
                function_entries.join(", ")
            ));
		}

		let mod_path = dir.join("mod.rs");
		std::fs::write(mod_path, mod_content).expect_error("Failed to write subdirectory mod.rs");
	}
}
